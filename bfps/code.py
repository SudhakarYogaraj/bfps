########################################################################
#
#  Copyright 2015 Max Planck Institute for Dynamics and SelfOrganization
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Contact: Cristian.Lalescu@ds.mpg.de
#
########################################################################


import bfps
from bfps.base import base
import subprocess
import os
import shutil
import pickle

class cluster_launcher:
    def __init__(
            self,
            file_name     = None,
            queue         = None,
            environment   = None,
            envprocs      = None,
            nprocesses    = None,
            name_of_run   = None,
            command_atoms = None,
            hours         = None,
            minutes       = None,
            seconds       = None,
            err_file      = None,
            out_file      = None,
            mail_address  = None,
            mail_events   = None):
        self.file_name     = file_name
        self.queue         = queue
        self.environment   = environment
        self.nprocesses    = nprocesses
        self.name_of_run   = name_of_run
        self.command_atoms = command_atoms
        self.hours         = hours
        self.minutes       = minutes
        self.seconds       = seconds
        self.err_file      = err_file
        self.out_file      = out_file
        self.mail_address  = mail_address
        self.mail_events   = mail_events
        if type(envprocs) == type(None):
            self.envprocs = self.nprocesses
        return None
    def write_pbs_file(self):
        script_file = open(file_name, 'w')
        script_file.write('#!/bin/tcsh\n'
                        + '#PBS -q ' + queue + '\n'
                        + '#PBS -l walltime={0}:{1}:{2}\n'.format(hours, minutes, seconds))
        if nprocesses%8 == 0:
            script_file.write('#PBS -l nodes={0}:ppn=8\n'.format(nprocesses/8))
        else:
            script_file.write('#PBS -l nodes={0}\n'.format(nprocesses))
        script_file.write('#PBS -j n\n'
                        + '#PBS -e ' + err_file + '\n'
                        + '#PBS -o ' + out_file + '\n'
                        + '#PBS -N ' + name_of_run + '\n\n')
        if mail_address != None:
            script_file.write('#PBS -M {0}\n'.format(mail_address))
            if mail_events != None:
                script_file.write('#PBS -m {0}\n\n'.format(mail_events))
        script_file.write('cd $PBS_O_WORKDIR\n'
                        + 'setenv MPI_NPROCS `wc -l $PBS_NODEFILE`\n'
                        + 'echo "Workdir is $PBS_O_WORKDIR"\n'
                        + 'echo Start time is `date`\n'
                        + 'mpirun -machinefile $PBS_NODEFILE ' + name_of_executable + '\n'
                        + 'echo End time is `date`\n')
        script_file.close()
        return None
    def write_sge_file(self):
        script_file = open(self.file_name, 'w')
        script_file.write('#!/bin/bash\n')
        # export all environment variables
        script_file.write('#$ -V\n')
        # job name
        script_file.write('#$ -N {0}\n'.format(self.name_of_run))
        # use current working directory
        script_file.write('#$ -cwd\n')
        # error file
        if not type(self.err_file) == type(None):
            script_file.write('#$ -e ' + self.err_file + '\n')
        # output file
        if not type(self.out_file) == type(None):
            script_file.write('#$ -o ' + self.out_file + '\n')
        if not type(self.environment) == type(None):
            script_file.write('#$ -pe {0} {1}\n'.format(self.environment, self.envprocs))
        script_file.write('echo "got $NSLOTS slots."\n')
        script_file.write('echo Start time is `date`\n')
        script_file.write('mpiexec -machinefile $TMPDIR/machines -n {0} {1}\n'.format(self.nprocesses, ' '.join(self.command_atoms)))
        script_file.write('echo End time is `date`\n')
        script_file.write('exit 0\n')
        script_file.close()
        return None

class code(base):
    def __init__(self):
        super(code, self).__init__()
        self.version_message = ('/***********************************************************************\n' +
                                '* this code automatically generated by bfps\n' +
                                '* version {0}\n'.format(bfps.__version__) +
                                '***********************************************************************/\n\n\n')
        self.includes = """
                //begincpp
                #include "base.hpp"
                #include "fluid_solver.hpp"
                #include <iostream>
                #include <fftw3-mpi.h>
                //endcpp
                """
        self.variables = 'int myrank, nprocs;\n'
        self.variables += 'int iter0;\n'
        self.variables += 'char simname[256];\n'
        self.definitions = ''
        self.main_start = """
                //begincpp
                int main(int argc, char *argv[])
                {
                    MPI_Init(&argc, &argv);
                    MPI_Comm_rank(MPI_COMM_WORLD, &myrank);
                    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
                    if (argc != 3)
                    {
                        std::cerr << "Wrong number of command line arguments. Stopping." << std::endl;
                        MPI_Finalize();
                        return EXIT_SUCCESS;
                    }
                    else
                    {
                        strcpy(simname, argv[1]);
                        iter0 = atoi(argv[2]);
                        std::cerr << "myrank = " << myrank <<
                                     ", simulation name is " << simname <<
                                     " and iter0 is " << iter0 << std::endl;
                    }
                    read_parameters();
                //endcpp
                """
        self.main_start += 'if (myrank == 0) std::cout << "{0}" << std::endl;'.format(self.version_message).replace('\n', '\\n') + '\n'
        self.main_start += 'if (myrank == 0) std::cerr << "{0}" << std::endl;'.format(self.version_message).replace('\n', '\\n') + '\n'
        self.main_end = """
                //begincpp
                    // clean up
                    fftwf_mpi_cleanup();
                    fftw_mpi_cleanup();
                    MPI_Finalize();
                    return EXIT_SUCCESS;
                }
                //endcpp
                """
        return None
    def write_src(self):
        with open(self.name + '.cpp', 'w') as outfile:
            outfile.write(self.version_message)
            outfile.write(self.includes)
            outfile.write(self.variables)
            outfile.write(self.definitions)
            outfile.write(self.main_start)
            outfile.write(self.main)
            outfile.write(self.main_end)
        return None
    def compile_code(self):
        # compile code
        if not os.path.isfile(os.path.join(bfps.header_dir, 'base.hpp')):
            raise IOError('header not there:\n' +
                          '{0}\n'.format(os.path.join(bfps.header_dir, 'base.hpp')) +
                          '{0}\n'.format(bfps.dist_loc))
        libraries = ['fftw3_mpi',
                     'fftw3',
                     'fftw3f_mpi',
                     'fftw3f',
                     'bfps']

        command_strings = ['mpicxx']
        command_strings += [self.name + '.cpp', '-o', self.name]
        command_strings += ['-O2'] + bfps.machine_settings['extra_compile_args']
        command_strings += ['-I' + idir for idir in bfps.machine_settings['include_dirs']]
        command_strings.append('-I' + bfps.header_dir)
        command_strings += ['-L' + ldir for ldir in bfps.machine_settings['library_dirs']]
        command_strings.append('-L' + bfps.lib_dir)
        for libname in libraries:
            command_strings += ['-l' + libname]
        return subprocess.call(command_strings)
    def run(self,
            ncpu = 2,
            simname = 'test',
            iter0 = 0,
            out_file = 'out_file',
            err_file = 'err_file',
            hostinfo = {'type' : ''}):
        if self.compile_code() == 0:
            current_dir = os.getcwd()
            if not os.path.isdir(self.work_dir):
                os.makedirs(self.work_dir)
            if self.work_dir != './':
                shutil.copy(self.name, self.work_dir)
            os.chdir(self.work_dir)
            with open(self.name + '_version_info.txt', 'w') as outfile:
                outfile.write(self.version_message)
            os.chdir(current_dir)
        command = ['mpirun',
                   '-np',
                   '{0}'.format(ncpu),
                   './' + self.name,
                   simname,
                   '{0}'.format(iter0)]
        if hostinfo['type'] == 'cluster':
            cl = cluster_launcher(
                file_name     = os.path.join(self.work_dir, 'run_' + simname + '.sh'),
                environment   = hostinfo['environment'],
                nprocesses    = ncpu,
                name_of_run   = self.name + '_' + simname,
                command_atoms = command[3:],
                hours         = 1,
                minutes       = 0,
                seconds       = 0,
                out_file      = out_file,
                err_file      = err_file)
            cl.write_sge_file()
        elif hostinfo['type'] == 'pc':
            os.chdir(self.work_dir)
            os.environ['LD_LIBRARY_PATH'] += ':{0}'.format(bfps.lib_dir)
            subprocess.call(command,
                            stdout = open(out_file + '_' + simname, 'w'),
                            stderr = open(err_file + '_' + simname, 'w'))
            os.chdir(current_dir)
        return command

