/***********************************************************************
* this code automatically generated by bfps
* version 2.0.1
***********************************************************************/



//begincpp
#include "base.hpp"
#include "fluid_solver.hpp"
#include "scope_timer.hpp"
#include <iostream>
#include <hdf5.h>
#include <string>
#include <cstring>
#include <fftw3-mpi.h>
//endcpp
#include "field.hpp"
#include <cstring>
#include <cmath>
#include "fftw_tools.hpp"
#include "rFFTW_interpolator.hpp"
#include <ctime>
#include "rFFTW_distributed_particles.hpp"

/// BEGIN NEW-PARTICLES
#include "particles_system.hpp"
#include "particles_interp_spline.hpp"
#include "abstract_particles_input.hpp"
#include "particles_input_hdf5.hpp"
/// END NEW-PARTICLES

int QR2D_histogram_bins;
int cubic_spline_neighbours;
int cubic_spline_smoothness;
char cubic_spline_type[512];
int dealias_type;
double dkx;
double dky;
double dkz;
double dt;
double famplitude;
double fk0;
double fk1;
int fmode;
char forcing_type[512];
int histogram_bins;
double max_Lag_acc_estimate;
double max_Q_estimate;
double max_R_estimate;
double max_pressure_estimate;
double max_trS2_estimate;
double max_velocity_estimate;
double max_vorticity_estimate;
int niter_out;
int niter_part;
int niter_stat;
int niter_todo;
int nparticles;
double nu;
int nx;
int ny;
int nz;
int tracers0_acc_on;
int tracers0_integration_steps;
char tracers0_interpolator[512];
int myrank, nprocs;
int iteration;
char simname[256], fname[256];
hid_t parameter_file, stat_file, Cdset;
fluid_solver<float> *fs;
field<float, FFTW, THREE> *tmp_vec_field;
field<float, FFTW, ONE> *tmp_scal_field;
kspace<FFTW, SMOOTH> *kk_smooth;
kspace<FFTW, TWO_THIRDS> *kk_two_thirds;
float *rFFTW_acc;
rFFTW_interpolator <float, 1> *cubic_spline;
//hid_t particle_file;
rFFTW_distributed_particles<VELOCITY_TRACER, float, 1> *ps0;
int read_parameters()
{
    hid_t parameter_file;
    hid_t dset, memtype, space;
    char fname[256];
    hsize_t dims[1];
    char *string_data;
    sprintf(fname, "%s.h5", simname);
    parameter_file = H5Fopen(fname, H5F_ACC_RDONLY, H5P_DEFAULT);
    dset = H5Dopen(parameter_file, "/parameters/QR2D_histogram_bins", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &QR2D_histogram_bins);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/cubic_spline_neighbours", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &cubic_spline_neighbours);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/cubic_spline_smoothness", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &cubic_spline_smoothness);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/cubic_spline_type", H5P_DEFAULT);
    space = H5Dget_space(dset);
    memtype = H5Dget_type(dset);
    string_data = (char*)malloc(256);
    H5Dread(dset, memtype, H5S_ALL, H5S_ALL, H5P_DEFAULT, &string_data);
    sprintf(cubic_spline_type, "%s", string_data);
    free(string_data);
    H5Sclose(space);
    H5Tclose(memtype);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/dealias_type", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &dealias_type);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/dkx", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &dkx);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/dky", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &dky);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/dkz", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &dkz);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/dt", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &dt);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/famplitude", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &famplitude);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/fk0", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &fk0);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/fk1", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &fk1);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/fmode", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &fmode);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/forcing_type", H5P_DEFAULT);
    space = H5Dget_space(dset);
    memtype = H5Dget_type(dset);
    string_data = (char*)malloc(256);
    H5Dread(dset, memtype, H5S_ALL, H5S_ALL, H5P_DEFAULT, &string_data);
    sprintf(forcing_type, "%s", string_data);
    free(string_data);
    H5Sclose(space);
    H5Tclose(memtype);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/histogram_bins", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &histogram_bins);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_Lag_acc_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_Lag_acc_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_Q_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_Q_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_R_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_R_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_pressure_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_pressure_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_trS2_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_trS2_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_velocity_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_velocity_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/max_vorticity_estimate", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &max_vorticity_estimate);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/niter_out", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &niter_out);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/niter_part", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &niter_part);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/niter_stat", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &niter_stat);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/niter_todo", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &niter_todo);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/nparticles", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nparticles);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/nu", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nu);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/nx", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nx);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/ny", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &ny);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/nz", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/tracers0_acc_on", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &tracers0_acc_on);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/tracers0_integration_steps", H5P_DEFAULT);
    H5Dread(dset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &tracers0_integration_steps);
    H5Dclose(dset);
    dset = H5Dopen(parameter_file, "/parameters/tracers0_interpolator", H5P_DEFAULT);
    space = H5Dget_space(dset);
    memtype = H5Dget_type(dset);
    string_data = (char*)malloc(256);
    H5Dread(dset, memtype, H5S_ALL, H5S_ALL, H5P_DEFAULT, &string_data);
    sprintf(tracers0_interpolator, "%s", string_data);
    free(string_data);
    H5Sclose(space);
    H5Tclose(memtype);
    H5Dclose(dset);
    H5Fclose(parameter_file);
    return 0;
}
int grow_single_dataset(hid_t dset, int tincrement)
{
    int ndims;
    hsize_t space;
    space = H5Dget_space(dset);
    ndims = H5Sget_simple_extent_ndims(space);
    hsize_t *dims = new hsize_t[ndims];
    H5Sget_simple_extent_dims(space, dims, NULL);
    dims[0] += tincrement;
    H5Dset_extent(dset, dims);
    H5Sclose(space);
    delete[] dims;
    return EXIT_SUCCESS;
}

typedef struct {
    float re;
    float im;
} tmp_complex_type;
herr_t grow_statistics_dataset(hid_t o_id, const char *name, const H5O_info_t *info, void *op_data)
{
    if (info->type == H5O_TYPE_DATASET)
    {
        hsize_t dset = H5Dopen(o_id, name, H5P_DEFAULT);
        grow_single_dataset(dset, niter_todo/niter_stat);
        H5Dclose(dset);
    }
    return 0;
}
//herr_t grow_particle_datasets(hid_t g_id, const char *name, const H5L_info_t *info, void *op_data)
//{
//    hsize_t dset;
//    if (H5Lexists(g_id, "state", H5P_DEFAULT))
//    {
//        dset = H5Dopen(g_id, "state", H5P_DEFAULT);
//        grow_single_dataset(dset, niter_todo/niter_part);
//        H5Dclose(dset);
//    }
//    if (H5Lexists(g_id, "velocity", H5P_DEFAULT))
//    {
//        dset = H5Dopen(g_id, "velocity", H5P_DEFAULT);
//        grow_single_dataset(dset, niter_todo/niter_part);
//        H5Dclose(dset);
//    }
//    if (H5Lexists(g_id, "acceleration", H5P_DEFAULT))
//    {
//        dset = H5Dopen(g_id, "acceleration", H5P_DEFAULT);
//        grow_single_dataset(dset, niter_todo/niter_part);
//        H5Dclose(dset);
//    }
//    if (H5Lexists(g_id, "rhs", H5P_DEFAULT))
//    {
//        dset = H5Dopen(g_id, "rhs", H5P_DEFAULT);
//        grow_single_dataset(dset, 1);
//        H5Dclose(dset);
//    }
//    return 0;
//}
int grow_file_datasets()
{
    int file_problems = 0;

    //begincpp
    hid_t group;
    group = H5Gopen(stat_file, "/statistics", H5P_DEFAULT);
    H5Ovisit(group, H5_INDEX_NAME, H5_ITER_NATIVE, grow_statistics_dataset, NULL);
    H5Gclose(group);
    //endcpp

    //    //begincpp
    //    group = H5Gopen(particle_file, "/tracers0", H5P_DEFAULT);
    //    grow_particle_datasets(group, "", NULL, NULL);
    //    H5Gclose(group);
    //    //endcpp
    return file_problems;
}
void do_stats()
{

    //begincpp
    hid_t stat_group;
    if (myrank == 0)
        stat_group = H5Gopen(stat_file, "statistics", H5P_DEFAULT);
    fs->compute_velocity(fs->cvorticity);
    std::vector<double> max_estimate_vector;
    max_estimate_vector.resize(4);
    *tmp_vec_field = fs->cvelocity;
    //    switch(fs->dealias_type)
    //    {
    //    case 0:
    //        tmp_vec_field->compute_stats(
    //                    kk_two_thirds,
    //                    stat_group,
    //                    "velocity",
    //                    fs->iteration / niter_stat,
    //                    max_velocity_estimate/sqrt(3));
    //        break;
    //    case 1:
    //        tmp_vec_field->compute_stats(
    //                    kk_smooth,
    //                    stat_group,
    //                    "velocity",
    //                    fs->iteration / niter_stat,
    //                    max_velocity_estimate/sqrt(3));
    //        break;
    //    }
    //    //endcpp

    //    //begincpp
    //    *tmp_vec_field = fs->cvorticity;
    //    switch(fs->dealias_type)
    //    {
    //    case 0:
    //        tmp_vec_field->compute_stats(
    //                    kk_two_thirds,
    //                    stat_group,
    //                    "vorticity",
    //                    fs->iteration / niter_stat,
    //                    max_vorticity_estimate/sqrt(3));
    //        break;
    //    case 1:
    //        tmp_vec_field->compute_stats(
    //                    kk_smooth,
    //                    stat_group,
    //                    "vorticity",
    //                    fs->iteration / niter_stat,
    //                    max_vorticity_estimate/sqrt(3));
    //        break;
    //    }
    //    //endcpp

    //begincpp
    if (myrank == 0)
        H5Gclose(stat_group);
    if (fs->cd->myrank == 0)
    {
        hid_t Cdset, wspace, mspace;
        int ndims;
        hsize_t count[4], offset[4], dims[4];
        offset[0] = fs->iteration/niter_stat;
        offset[1] = 0;
        offset[2] = 0;
        offset[3] = 0;
        //endcpp
        Cdset = H5Dopen(stat_file, "/statistics/xlines/velocity", H5P_DEFAULT);

        count[0] = 1;
        count[1] = nx;
        count[2] = 3;
        wspace = H5Dget_space(Cdset);
        ndims = H5Sget_simple_extent_dims(wspace, dims, NULL);
        mspace = H5Screate_simple(ndims, count, NULL);
        H5Sselect_hyperslab(wspace, H5S_SELECT_SET, offset, NULL, count, NULL);
        H5Dwrite(Cdset, H5T_NATIVE_FLOAT, mspace, wspace, H5P_DEFAULT, fs->rvelocity);
        H5Dclose(Cdset);
        Cdset = H5Dopen(stat_file, "/statistics/xlines/vorticity", H5P_DEFAULT);
        H5Dwrite(Cdset, H5T_NATIVE_FLOAT, mspace, wspace, H5P_DEFAULT, fs->rvorticity);
        H5Dclose(Cdset);
        H5Sclose(mspace);
        H5Sclose(wspace);
    }
}
//void do_particle_stats()
//{
//    if (ps0->iteration % niter_part == 0)
//    {
//        ps0->write(false);
//        {
//            fs->compute_velocity(fs->cvorticity);
//            fs->ift_velocity();
//            fs->compute_Lagrangian_acceleration(rFFTW_acc);

//            cubic_spline->read_rFFTW(fs->rvelocity);
//            ps0->sample(cubic_spline, "velocity");

//            cubic_spline->read_rFFTW(rFFTW_acc);
//            ps0->sample(cubic_spline, "acceleration");
//        }
//    }
//}

//begincpp
int main(int argc, char *argv[])
{
    MPI_Init(&argc, &argv);
    MPI_Comm_rank(MPI_COMM_WORLD, &myrank);
    MPI_Comm_size(MPI_COMM_WORLD, &nprocs);
    fftw_mpi_init();
    fftwf_mpi_init();
    if (argc != 2)
    {
        std::cerr << "Wrong number of command line arguments. Stopping." << std::endl;
        MPI_Finalize();
        return EXIT_SUCCESS;
    }
    strcpy(simname, argv[1]);
    sprintf(fname, "%s.h5", simname);
    parameter_file = H5Fopen(fname, H5F_ACC_RDONLY, H5P_DEFAULT);
    Cdset = H5Dopen(parameter_file, "iteration", H5P_DEFAULT);
    H5Dread(Cdset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &iteration);
    DEBUG_MSG("simname is %s and iteration is %d\n", simname, iteration);
    H5Dclose(Cdset);
    H5Fclose(parameter_file);
    read_parameters();
    if (myrank == 0)
    {
        // set caching parameters
        hid_t fapl = H5Pcreate(H5P_FILE_ACCESS);
        herr_t cache_err = H5Pset_cache(fapl, 0, 521, 134217728, 1.0);
        DEBUG_MSG("when setting stat_file cache I got %d\n", cache_err);
        stat_file = H5Fopen(fname, H5F_ACC_RDWR, fapl);
    }
    {
        TIMEZONE("code::main_start");
        //endcpp
        if (myrank == 0) std::cout << "/***********************************************************************\n* this code automatically generated by bfps\n* version 2.0.1\n***********************************************************************/\n\n\n" << std::endl;
        if (myrank == 0) std::cerr << "/***********************************************************************\n* this code automatically generated by bfps\n* version 2.0.1\n***********************************************************************/\n\n\n" << std::endl;

        //begincpp
        if (myrank == 0)
        {
            char fname[256];
            sprintf(fname, "%s_fftw_wisdom.txt", simname);
            fftwf_import_wisdom_from_filename(fname);
        }
        fftwf_mpi_broadcast_wisdom(MPI_COMM_WORLD);
        //endcpp

        if (myrank == 0)
        {
            // set caching parameters
            hid_t fapl = H5Pcreate(H5P_FILE_ACCESS);
            herr_t cache_err = H5Pset_cache(fapl, 0, 521, 134217728, 1.0);
            DEBUG_MSG("when setting cache for particles I got %d\n", cache_err);
            sprintf(fname, "%s_particles.h5", simname);
            particle_file = H5Fopen(fname, H5F_ACC_RDWR, fapl);
        }

        //begincpp
        int data_file_problem;
        clock_t time0, time1;
        double time_difference, local_time_difference;
        time0 = clock();
        if (myrank == 0) data_file_problem = grow_file_datasets();
        MPI_Bcast(&data_file_problem, 1, MPI_INT, 0, MPI_COMM_WORLD);
        if (data_file_problem > 0)
        {
            std::cerr << data_file_problem << " problems growing file datasets.\ntrying to exit now." << std::endl;
            MPI_Finalize();
            return EXIT_SUCCESS;
        }
        //endcpp

        //begincpp
        char fname[512];
        fs = new fluid_solver<float>(
                    simname,
                    nx, ny, nz,
                    dkx, dky, dkz,
                    dealias_type,
                    FFTW_MEASURE);
        tmp_vec_field = new field<float, FFTW, THREE>(
                    nx, ny, nz,
                    MPI_COMM_WORLD,
                    FFTW_MEASURE);
        tmp_scal_field = new field<float, FFTW, ONE>(
                    nx, ny, nz,
                    MPI_COMM_WORLD,
                    FFTW_MEASURE);
        kk_smooth = new kspace<FFTW, SMOOTH>(
                    tmp_vec_field->clayout,
                    fs->dkx, fs->dky, fs->dkz);
        kk_two_thirds = new kspace<FFTW, TWO_THIRDS>(
                    tmp_vec_field->clayout,
                    fs->dkx, fs->dky, fs->dkz);
        fs->nu = nu;
        fs->fmode = fmode;
        fs->famplitude = famplitude;
        fs->fk0 = fk0;
        fs->fk1 = fk1;
        strncpy(fs->forcing_type, forcing_type, 128);
        fs->iteration = iteration;
        fs->read('v', 'c');
        //endcpp

        //begincpp
        if (myrank == 0 && iteration == 0)
        {
            TIMEZONE("fuild_base::store_kspace");
            hsize_t dims[4];
            hid_t space, dset;
            // store kspace information
            hid_t parameter_file = stat_file;
            //char fname[256];
            //sprintf(fname, "%s.h5", simname);
            //parameter_file = H5Fopen(fname, H5F_ACC_RDWR, H5P_DEFAULT);
            dset = H5Dopen(parameter_file, "/kspace/kshell", H5P_DEFAULT);
            space = H5Dget_space(dset);
            H5Sget_simple_extent_dims(space, dims, NULL);
            H5Sclose(space);
            if (fs->nshells != dims[0])
            {
                DEBUG_MSG(
                            "ERROR: computed nshells %d not equal to data file nshells %d\n",
                            fs->nshells, dims[0]);
            }
            H5Dwrite(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, fs->kshell);
            H5Dclose(dset);
            dset = H5Dopen(parameter_file, "/kspace/nshell", H5P_DEFAULT);
            H5Dwrite(dset, H5T_NATIVE_INT64, H5S_ALL, H5S_ALL, H5P_DEFAULT, fs->nshell);
            H5Dclose(dset);
            dset = H5Dopen(parameter_file, "/kspace/kM", H5P_DEFAULT);
            H5Dwrite(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &fs->kMspec);
            H5Dclose(dset);
            dset = H5Dopen(parameter_file, "/kspace/dk", H5P_DEFAULT);
            H5Dwrite(dset, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, H5P_DEFAULT, &fs->dk);
            H5Dclose(dset);
            //H5Fclose(parameter_file);
        }
        //endcpp
        //        rFFTW_acc = fftwf_alloc_real(2*fs->cd->local_size);
        //        cubic_spline = new rFFTW_interpolator<float, 1>(fs, beta_n1_m1, fs->rvelocity);
        fs->compute_velocity(fs->cvorticity);
        fs->ift_velocity();
        //        sprintf(fname, "tracers0");
        //        ps0 = new rFFTW_distributed_particles<VELOCITY_TRACER, float, 1>(
        //                    fname, particle_file, cubic_spline,
        //                    niter_part, tracers0_integration_steps);
        //        ps0->dt = dt;
        //        ps0->iteration = iteration;
        //        ps0->read();

        // Interpolator size
        const int InterpNbNeighbors = 5;

        // Only the Z grid
        const std::array<size_t,3> field_grid_dim{nx,ny,nz};
        assert(myrank < field_grid_dim);
        const int myPartitionInterval[2] = {fs->cvelocity->rlayout->start[0],
                                            fs->cvelocity->rlayout->start[0] + fs->cvelocity->rlayout->subsizes[0]};

        const std::array<double,3> spatial_box_width{dkx, dky, dkz};
        const double spatial_partition_width = spatial_box_width/double(field_grid_dim);
        const double my_spatial_low_limit = myPartitionInterval[0]*spatial_partition_width;
        const double my_spatial_up_limit = myPartitionInterval[1]*spatial_partition_width;

        std::array<size_t,3> field_dims[3]{ field_grid_dim, field_grid_dim, myPartitionInterval[1]-myPartitionInterval[0]};
        std::array<size_t,3> field_offset[3]{ 0, 0, myPartitionInterval[0]};

        particles_system<particles_interp_spline<InterpNbNeighbors,0>, InterpNbNeighbors> part_sys(field_grid_dim,
                                                                                                   spatial_box_width,
                                                                                                   spatial_partition_width,
                                                                                                   my_spatial_low_limit,
                                                                                                   my_spatial_up_limit,
                                                                                                   fs->cvorticity,
                                                                                                   field_dims,
                                                                                                   field_offset,
                                                                                                   MPI_COMM_WORLD);
        {
            particles_input_hdf5<3,3> generator(MPI_COMM_WORLD, fname,
                                                "tracers0", my_spatial_low_limit, my_spatial_up_limit);
            part_sys.init(generator);
        }

        {
            particles_output_hdf5<3,3> particles_output_writer(MPI_COMM_WORLD, fname, nb_particles);

            for (int max_iter = iteration+niter_todo; iteration < max_iter; iteration++)
            {
                //            if (iteration % niter_stat == 0) do_stats();
                //            if (iteration % niter_part == 0) do_particle_stats();
                fs->compute_velocity(fs->cvorticity);
                fs->ift_velocity();
                //            cubic_spline->read_rFFTW(fs->rvelocity);
                //            ps0->step();
                //            fs->step(dt);
                part_sys.completeLoop(dt);
                particles_output_writer_mpi.save(part_sys.getParticlesPositions(),
                                                 part_sys.getParticlesCurrentRhs(),
                                                 part_sys.getParticlesIndexes(),
                                                 part_sys.getLocalNbParticles(), iteration);
                if (fs->iteration % niter_out == 0)
                {
                    fs->write('v', 'c');

                }
                time1 = clock();
                local_time_difference = ((unsigned int)(time1 - time0))/((double)CLOCKS_PER_SEC);
                time_difference = 0.0;
                MPI_Allreduce(&local_time_difference, &time_difference, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
                if (myrank == 0) std::cout << "iteration " << iteration << " took " << time_difference/nprocs << " seconds" << std::endl;
                if (myrank == 0) std::cerr << "iteration " << iteration << " took " << time_difference/nprocs << " seconds" << std::endl;
                time0 = time1;
            }
        }
        do_stats();
        do_particle_stats();
        time1 = clock();
        local_time_difference = ((unsigned int)(time1 - time0))/((double)CLOCKS_PER_SEC);
        time_difference = 0.0;
        MPI_Allreduce(&local_time_difference, &time_difference, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
        if (myrank == 0) std::cout << "iteration " << iteration << " took " << time_difference/nprocs << " seconds" << std::endl;
        if (myrank == 0) std::cerr << "iteration " << iteration << " took " << time_difference/nprocs << " seconds" << std::endl;
        time0 = time1;
        ps0->write();
        delete ps0;
        if (fs->iteration % niter_out != 0)
        {
            fs->write('v', 'c');

        }
        delete fs;
        delete tmp_vec_field;
        delete tmp_scal_field;
        delete kk_smooth;
        delete kk_two_thirds;
        fftwf_free(rFFTW_acc);
        delete cubic_spline;
        if (myrank == 0)
        {
            H5Fclose(particle_file);
        }

        //begincpp
        fftwf_mpi_gather_wisdom(MPI_COMM_WORLD);
        MPI_Barrier(MPI_COMM_WORLD);
        if (myrank == 0)
        {
            char fname[256];
            sprintf(fname, "%s_fftw_wisdom.txt", simname);
            fftwf_export_wisdom_to_filename(fname);
        }
        //endcpp

        //begincpp
    }
    // clean up
    if (myrank == 0)
    {
        Cdset = H5Dopen(stat_file, "iteration", H5P_DEFAULT);
        H5Dwrite(Cdset, H5T_NATIVE_INT, H5S_ALL, H5S_ALL, H5P_DEFAULT, &iteration);
        H5Dclose(Cdset);
        H5Fclose(stat_file);
    }
    fftwf_mpi_cleanup();
    fftw_mpi_cleanup();
#ifdef USE_TIMINGOUTPUT
    global_timer_manager.show(MPI_COMM_WORLD);
    global_timer_manager.showMpi(MPI_COMM_WORLD);
#endif
    MPI_Finalize();
    return EXIT_SUCCESS;
}
//endcpp
